/*
 * Copyright (C) 2020 Kode Devs
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package kode;

import java.io.File;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

import kni.KodeObject;
import math.KodeMath;
import math.KodeNumber;

/**
 * <B><center>--- Interpreter for KODE interpreter ---</center></B>
 * <p>
 * Interpreter traverses through the AST and preforms the real execution of the
 * source code. Each Node has some associated operations written inside the
 * Interpreter, which needs to be performed according to the Nodes. For an
 * Example, the Binary Operation Node, firstly interprets the left and right
 * nodes to get the requested values, and then performs the suitable operations
 * over the left and right value using a switch case statement over the operator
 * mentioned. At the end it returns the result as the result of the node.
 * </p>
 *
 * <p>
 * The default syntax to perform Interpretation is
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;  <code>
 * new Interpreter().interpret(&lt;list of statements&gt;);
 * </code><br>where, {@code list of statements} is the root of AST generated by
 * the Syntax Analyzer and verified by the Semantic Analyzer.</p>
 *
 * @author Arpan Mahanty < edumate696@gmail.com >
 * @see Interpreter#interpret(List)
 * @see Interpreter()
 */
class Interpreter implements Expr.Visitor<KodeObject>, Stmt.Visitor<KodeObject> {

    /**
     * Global Symbol Table.
     */
    Environment globals;

    /**
     * Symbol Table for the current scope.
     */
    private Environment environment;

    /**
     * This field is accessed by the resolver and contains the scope distance at
     * which you can find any local variable w.r.t the variable access
     * expression.
     */
    private final Map<Expr, Integer> locals;

    /**
     * Creates an instance of the Interpreter to scan the AST generated by the
     * Syntax Analyzer and verified by the Semantic Analyzer.
     */
    Interpreter() {
        this.environment = this.globals = new Environment();
        this.locals = new HashMap<>();
    }

    /**
     * Scans through the list of Statement Nodes and thus execute it where each
     * Node represents each single statement. The interpreter starts its
     * execution from this point, when the root of the AST is passed as the list
     * of statements.
     *
     * @param statements List of Statements.
     * @return Returns the result of the last statement from the list.
     * @see Stmt
     */
    KodeObject interpret(List<Stmt> statements) {
        try {
            KodeObject ret = null;
            for (Stmt statement : statements) {
                ret = execute(statement);
            }
            return ret;
        } catch (StackOverflowError error) {
            throw new RuntimeError("Max Depth of Recursion Exceeded.");
        } catch (OutOfMemoryError error) {
            throw new RuntimeError(error.getMessage());
        } catch (RuntimeError error) {
            throw error;
        } catch (Throwable error) {
            throw new RuntimeError("Fatal: " + error.getMessage());
        }
    }

    @Override
    public KodeObject visitLiteralExpr(Expr.Literal expr) {
        return toKodeValue(expr.value);
    }

    @Override
    public KodeObject visitLogicalExpr(Expr.Logical expr) {
        KodeObject left = evaluate(expr.left);

        if (expr.operator.type == TokenType.OR) {
            if (isTruthy(left)) {
                return left;
            }
        } else {
            if (!isTruthy(left)) {
                return left;
            }
        }

        return evaluate(expr.right);
    }

    @Override
    public KodeObject visitSetExpr(Expr.Set expr) {
        KodeObject object = evaluate(expr.object);

        if (expr.name.lexeme.equals(Kode.CLASS)) {
            throw new RuntimeError("Can not change '" + expr.name.lexeme + "' attribute of any instance.", expr.name);
        }

        KodeObject value = evaluate(expr.value);
        try {
            object.set(expr.name.lexeme, value);
        } catch (RuntimeError e) {
            e.token.add(expr.name);
            throw e;
        }
        return value;
    }

    @Override
    public KodeObject visitSuperExpr(Expr.Super expr) {
        int distance = locals.get(expr);
        KodeClass superclass = (KodeClass) environment.getAt(distance, "super");
        KodeFunction method = superclass.findMethod(expr.method.lexeme);
        if (method == null) {
            throw new RuntimeError("Undefined property '" + expr.method.lexeme + "'.", expr.method);
        }
        return method;
    }

    @Override
    public KodeObject visitGroupingExpr(Expr.Grouping expr) {
        return evaluate(expr.expression);
    }

    /**
     * Scans a specific Expression Node.
     */
    KodeObject evaluate(Expr expr) {
        // Calling accept on node executes the necessary function defined in the object passed as parameter.
        return expr.accept(this);
    }

    /**
     * Scans a specific Statement Node representing a single statement.
     */
    KodeObject execute(Stmt stmt) {
        // Calling accept on node executes the necessary function defined in the object passed as parameter.
        return stmt.accept(this);
    }

    /**
     * Stores the expression node reference, and it associated scope depth into
     * the instance of the interpreter.
     */
    void resolve(Expr expr, int depth) {
        locals.put(expr, depth);
    }

    /**
     * This method helps to execute a block of statements w.r.t the current
     * scope.
     */
    void executeBlock(List<Stmt> statements, Environment env) {
        Environment previous = this.environment;
        try {
            this.environment = env;
            statements.forEach(this::execute);
        } finally {
            this.environment = previous;
        }
    }

    @Override
    public KodeObject visitBlockStmt(Stmt.Block stmt) {
        executeBlock(stmt.statements, new Environment(environment));
        return null;
    }

    @Override
    public KodeObject visitClassStmt(Stmt.Class stmt) {
        KodeObject superclass = null;
        if (stmt.superclass != null) {
            superclass = evaluate(stmt.superclass);
            if (!(superclass instanceof KodeClass)) {
                throw new RuntimeError("Superclass must be a class.", stmt.superclass.name);
            }
        }

        environment.define(stmt.name.lexeme, null);

        if (stmt.superclass != null) {
            environment = new Environment(environment);
            environment.define("super", superclass);
        }

        Map<String, KodeFunction> methods = new HashMap<>();
        stmt.methods.forEach((method) -> {
            KodeFunction function = new KodeFunction(method, environment, this, method.name.lexeme.equals(Kode.INIT));
            methods.put(method.name.lexeme, function);
        });

        KodeClass klass = new KodeClass(stmt.name.lexeme, (KodeClass) superclass, methods, this);

        if (superclass != null) {
            environment = environment.enclosing;
        }

        klass.__doc__ = stmt.doc;
        environment.assign(stmt.name, klass);
        return null;
    }

    @Override
    public KodeObject visitExpressionStmt(Stmt.Expression stmt) {
        return evaluate(stmt.expression);
    }

    @Override
    public KodeObject visitFunctionStmt(Stmt.Function stmt) {
        KodeFunction function = new KodeFunction(stmt, environment, this, false);
        function.__doc__ = stmt.doc;
        environment.define(stmt.name.lexeme, function);
        return null;
    }

    @Override
    public KodeObject visitIfStmt(Stmt.If stmt) {
        if (isTruthy(evaluate(stmt.condition))) {
            execute(stmt.thenBranch);
        } else if (stmt.elseBranch != null) {
            execute(stmt.elseBranch);
        }
        return null;
    }

    @Override
    public KodeObject visitRequireStmt(Stmt.Require stmt) {
        List<String> dir = new ArrayList<>();
        stmt.dir.forEach((item) -> dir.add(item.lexeme));

        String join = String.join(File.separator, dir);
        try {
            KodeModule module;
            if (Kode.ModuleRegistry.containsKey(join)) {
                module = Kode.ModuleRegistry.get(join);
            } else {
                module = new KodeModule(String.join(".", dir), join);
                Kode.ModuleRegistry.put(join, module);
                module.inter.globals.define(Kode.__NAME__, toKodeValue(stmt.imp.fn));
                try {
                    module.runModule();
                } catch (Throwable e) {
                    Kode.ModuleRegistry.remove(join);
                    throw e;
                }
            }
            if (stmt.methods != null) {
                stmt.methods.forEach((item) -> environment.define(item.lexeme, module.get(item)));
            } else {
                environment.define(stmt.alias != null ? stmt.alias.lexeme : dir.get(dir.size() - 1), module);
            }
            return null;
        } catch (RuntimeError e) {
            e.token.add(stmt.imp);
            throw e;
        } catch (Throwable e) {
            throw new RuntimeError("Failed to Import Module '" + String.join(".", dir) + "'.", stmt.imp);
        }
    }

    @Override
    public KodeObject visitRaiseStmt(Stmt.Raise stmt) {
        KodeObject value = evaluate(stmt.value);
        if (value instanceof KodeInstance) {
            if (ValueNotImplemented.isNotImplemented((KodeInstance) value)) {
                RuntimeError e = new NotImplemented((KodeInstance) value);
                e.token.add(stmt.keyword);
                throw e;
            }
            if (ValueError.isError((KodeInstance) value)) {
                RuntimeError e = new RuntimeError((KodeInstance) value);
                e.token.add(stmt.keyword);
                throw e;
            }
        }
        throw new RuntimeError("Can only raise instances of Error class or its sub-classes but found element of type '"
                + Kode.type(value) + "'.", stmt.keyword);
    }

    @Override
    public KodeObject visitReturnStmt(Stmt.Return stmt) {
        throw new Return(stmt.value != null ? evaluate(stmt.value) : null);
    }

    @Override
    public KodeObject visitBreakStmt(Stmt.Break stmt) {
        throw new Break();
    }

    @Override
    public KodeObject visitContinueStmt(Stmt.Continue stmt) {
        throw new Continue();
    }

    @Override
    public KodeObject visitVarStmt(Stmt.Var stmt) {
        for (int i = 0; i < stmt.name.size(); i++) {
            KodeObject value;
            if (stmt.initial.get(i) != null) {
                value = evaluate(stmt.initial.get(i));
                if (value == null) {
                    throw new RuntimeError("The expression associated with variable '" + stmt.name.get(i).lexeme
                            + "' does not return any value.", stmt.name.get(i));
                }
            } else {
                value = ValueNone.create();
            }
            environment.define(stmt.name.get(i).lexeme, value);
        }
        return null;
    }

    @Override
    public KodeObject visitWhileStmt(Stmt.While stmt) {
        while (isTruthy(evaluate(stmt.condition))) {
            try {
                execute(stmt.body);
            } catch (Break b) {
                break;
            } catch (Continue ignored) {
            }
        }
        return null;
    }

    @Override
    public KodeObject visitForStmt(Stmt.For stmt) {
        if (stmt.init != null) {
            execute(stmt.init);
        }
        while (isTruthy(evaluate(stmt.condition))) {
            try {
                execute(stmt.body);
            } catch (Break b) {
                break;
            } catch (Continue ignored) {
            }
            if (stmt.increment != null) {
                execute(stmt.increment);
            }
        }
        return null;
    }

    @Override
    public KodeObject visitAssignExpr(Expr.Assign expr) {
        KodeObject value = evaluate(expr.value);
        if (value == null) {
            throw new RuntimeError(
                    "The expression associated with variable '" + expr.name.lexeme + "' does not return any value.",
                    expr.name);
        }
        Integer distance = locals.get(expr);
        if (distance != null) {
            environment.assignAt(distance, expr.name, value);
        } else {
            globals.assign(expr.name, value);
        }
        return value;
    }

    /**
     * Utility function to perform a binary operation in a layered manner.
     * Firstly, it tries to perform <coe>left.lop(right)</code>, if it gets an
     * {@link NotImplemented} error then it goes for
     * <code>right.rop(left)</code>. Again on similar failure it generates
     * suitable error message for the binary operation.
     *
     * @param left  Left Value
     * @param right Right Value
     * @param lop   Name of associated function in left object.
     * @param rop   Name of associated function in right object.
     * @param op    Operator as a reference for the error message.
     * @return Returns the resultant value.
     */
    private KodeObject BinOP(KodeObject left, KodeObject right, String lop, String rop, Token op) {
        if (left instanceof KodeInstance) {
            try {
                Object fun = left.get(lop);
                if (fun instanceof KodeFunction) {
                    return ((KodeFunction) fun).call(right);
                }
            } catch (NotImplemented ignored) {
            }
        }
        if (right instanceof KodeInstance) {
            try {
                Object fun = right.get(rop);
                if (fun instanceof KodeFunction) {
                    return ((KodeFunction) fun).call(left);
                }
            } catch (NotImplemented ignored) {
            }
        }
        if (lop.equals(rop) && lop.equals(Kode.EQ)) {
            return toKodeValue(Objects.equals(left, right));
        }
        if (lop.equals(rop) && lop.equals(Kode.NE)) {
            return toKodeValue(!Objects.equals(left, right));
        }
        throw new RuntimeError("Binary Operation '" + op.lexeme + "' can not be performed between operands of type '"
                + Kode.type(left) + "' and '" + Kode.type(right) + "'.", op);
    }

    @Override
    public KodeObject visitBinaryExpr(Expr.Binary expr) {
        KodeObject left = evaluate(expr.left);
        KodeObject right = evaluate(expr.right);

        switch (expr.operator.type) {
            case GREATER:
                return BinOP(left, right, Kode.GT, Kode.GT, expr.operator);
            case GREATER_EQUAL:
                return BinOP(left, right, Kode.GE, Kode.GE, expr.operator);
            case LESS:
                return BinOP(left, right, Kode.LT, Kode.LT, expr.operator);
            case LESS_EQUAL:
                return BinOP(left, right, Kode.LE, Kode.LE, expr.operator);
            case LSHIFT:
                return BinOP(left, right, Kode.LSHIFT, Kode.RLSHIFT, expr.operator);
            case RSHIFT:
                return BinOP(left, right, Kode.RSHIFT, Kode.RRSHIFT, expr.operator);
            case MINUS:
                return BinOP(left, right, Kode.SUB, Kode.RSUB, expr.operator);
            case PLUS:
                return BinOP(left, right, Kode.ADD, Kode.RADD, expr.operator);
            case SLASH:
                return BinOP(left, right, Kode.TRUE_DIV, Kode.RTRUE_DIV, expr.operator);
            case STAR:
                return BinOP(left, right, Kode.MUL, Kode.RMUL, expr.operator);
            case PERCENT:
                return BinOP(left, right, Kode.MOD, Kode.RMOD, expr.operator);
            case BACKSLASH:
                return BinOP(left, right, Kode.FLOOR_DIV, Kode.RFLOOR_DIV, expr.operator);
            case POWER:
                return BinOP(left, right, Kode.POWER, Kode.RPOWER, expr.operator);
            case BANG_EQUAL:
                return BinOP(left, right, Kode.NE, Kode.NE, expr.operator);
            case EQUAL_EQUAL:
                return BinOP(left, right, Kode.EQ, Kode.EQ, expr.operator);
            default:
                throw new RuntimeError(
                        "Binary Operation '" + expr.operator + "' can not be performed between operands of type '"
                                + Kode.type(left) + "' and '" + Kode.type(right) + "'.",
                        expr.operator);
        }
    }

    @Override
    public KodeObject visitCallExpr(Expr.Call expr) {
        KodeObject callee = evaluate(expr.callee);

        KodeObject[] arguments = new KodeObject[expr.arguments.length];
        for (int i = 0; i < expr.arguments.length; i++) {
            arguments[i] = evaluate(expr.arguments[i]);
        }

        try {
            return callee.call(arguments);
        } catch (RuntimeError e) {
            e.token.add(expr.paren);
            throw e;
        }
    }

    @Override
    public KodeObject visitGetATIndexExpr(Expr.GetAtIndex expr) {
        KodeObject array = evaluate(expr.array);
        KodeObject index = evaluate(expr.index);
        if (array instanceof KodeInstance) {
            KodeFunction method = ((KodeInstance) array).klass.findMethod(Kode.GET_ITEM);
            try {
                return method.bind((KodeInstance) array).call(index);
            } catch (NotImplemented e) {
                throw new RuntimeError(Kode.type(array) + " object is non-indexable.", expr.paren);
            }
        } else {
            throw new RuntimeError(Kode.type(array) + " object is non-indexable.", expr.paren);
        }
    }

    @Override
    public KodeObject visitSetATIndexExpr(Expr.SetAtIndex expr) {
        KodeObject value = evaluate(expr.value);
        KodeObject array = evaluate(expr.array);
        KodeObject index = evaluate(expr.index);
        if (array instanceof KodeInstance) {
            KodeFunction method = ((KodeInstance) array).klass.findMethod(Kode.SET_ITEM);
            try {
                return method.bind((KodeInstance) array).call(index, value);
            } catch (NotImplemented e) {
                throw new RuntimeError(Kode.type(array) + " object does not support item assignment.", expr.paren);
            }
        } else {
            throw new RuntimeError(Kode.type(array) + " object is non-indexable.", expr.paren);
        }
    }

    @Override
    public KodeObject visitGetExpr(Expr.Get expr) {
        KodeObject object = evaluate(expr.object);
        if (object == null) {
            throw new RuntimeError("No such object found", expr.name);
        }
        try {
            return object.get(expr.name.lexeme);
        } catch (RuntimeError e) {
            e.token.add(expr.name);
            throw e;
        }
    }

    @Override
    public KodeObject visitUnaryExpr(Expr.Unary expr) {
        KodeObject right = evaluate(expr.right);

        switch (expr.operator.type) {
            case BANG:
                return toKodeValue(!isTruthy(right));
            case MINUS:
                if (right instanceof KodeInstance) {
                    try {
                        Object fun = right.get(Kode.NEG);
                        if (fun instanceof KodeFunction) {
                            return ((KodeFunction) fun).call();
                        }
                    } catch (NotImplemented ignored) {
                    }
                }
                throw new RuntimeError("Unary Operation '" + expr.operator.lexeme
                        + "' can not be performed on operand of type '" + Kode.type(right) + "'.", expr.operator);
            case PLUS:
                if (right instanceof KodeInstance) {
                    try {
                        Object fun = right.get(Kode.POS);
                        if (fun instanceof KodeFunction) {
                            return ((KodeFunction) fun).call();
                        }
                    } catch (NotImplemented ignored) {
                    }
                }
                throw new RuntimeError("Unary Operation '" + expr.operator.lexeme
                        + "' can not be performed on operand of type '" + Kode.type(right) + "'.", expr.operator);
            default:
                return right;
        }

    }

    @Override
    public KodeObject visitArrayExpr(Expr.Array expr) {
        List<Object> arr = new ArrayList<>();
        expr.array.forEach((ex) -> arr.add(evaluate(ex)));
        return toKodeValue(arr);
    }

    @Override
    public KodeObject visitVariableExpr(Expr.Variable expr) {
        return lookUpVariable(expr.name, expr);
    }

    @Override
    public KodeObject visitNativeExpr(Expr.Native expr) {
        List<String> temp = new ArrayList<>();
        expr.path.forEach(i -> temp.add(i.lexeme));
//        String className = String.join(".", temp);
        throw new RuntimeError("Deprecated", expr.nav);
    }

    @Override
    public KodeObject visitTryStmt(Stmt.Try stmt) {
        try {
            executeBlock(stmt.tryStmt, new Environment(environment));
        } catch (RuntimeError e) {
            for (Stmt.Catch c : stmt.catchs) {
                Object err_type = c.ErrorType == null ? ValueError.val : evaluate(c.ErrorType);
                KodeClass cls;
                if (err_type instanceof ValueError) {
                    cls = (ValueError) err_type;
                } else {
                    assert c.ErrorType != null;
                    throw new RuntimeError(c.ErrorType.name.lexeme + " is not a Error class name", c.ErrorType.name);
                }
                if (Kode.instanceOf(e.instance, cls)) {
                    c.instance = e.instance;
                    this.execute(c);
                    return null;
                }
            }
            throw e;
        }
        return null;
    }

    @Override
    public KodeObject visitCatchStmt(Stmt.Catch stmt) {
        Environment env = new Environment(this.environment);
        if (stmt.alias != null) {
            env.define(stmt.alias.lexeme, stmt.instance);
        }
        executeBlock(stmt.catchStmt, env);
        return null;
    }

    /**
     * Retrieve the actual value of a variable from the symbol table.
     */
    private KodeObject lookUpVariable(Token name, Expr expr) {
        Integer distance = locals.get(expr);
        if (distance != null) {
            return environment.getAt(distance, name.lexeme);
        } else {
            return globals.get(name);
        }
    }

    /**
     * Checks weather an object is conditionally true, or not.
     */
    static boolean isTruthy(Object object) {
        if (object == null) {
            return false;
        }
        if (object instanceof Boolean) {
            return (boolean) object;
        }
        if (object instanceof KodeNumber) {
            return KodeMath.not_equal((KodeNumber) object, KodeNumber.valueOf("0"));
        }
        if (object instanceof String) {
            return ((String) object).length() != 0;
        }
        if (object instanceof List) {
            return !((List<?>) object).isEmpty();
        }
        if (object instanceof KodeInstance) {
            if (ValueBool.isBool((KodeInstance) object)) {
                return ValueBool.toBoolean((KodeInstance) object);
            }
            Object method = ((KodeInstance) object).get(Kode.BOOLEAN);
            if (method instanceof KodeFunction) {
                return isTruthy(((KodeFunction) method).bind((KodeInstance) object).call());
            }
            return true;
        }
        return true;
    }

    /**
     * Converts a Java object to suitable KODE object. If it fails to do its
     * task, then it returns the object without converting it.
     */
    static KodeObject toKodeValue(Object value) {
        if (value == null) {
            return ValueNone.create();
        } else if (value instanceof KodeNumber) {
            return ValueNumber.create((KodeNumber) value);
        } else if (value instanceof Number) {
            return ValueNumber.create(KodeNumber.valueOf((Number) value));
        } else if (value instanceof String) {
            return ValueString.create((String) value);
        } else if (value instanceof Character) {
            return ValueString.create("" + value);
        } else if (value instanceof Boolean) {
            return ValueBool.create((Boolean) value);
        } else if (value instanceof List) {
            final List<KodeObject> ll = new ArrayList<>();
            ((List<?>) value).forEach((item) -> ll.add(Interpreter.toKodeValue(item)));
            return ValueList.create(ll);
        } else if (value.getClass().isArray()) {
            return Interpreter.toKodeValue(ArrayObject2List(value));
        } else if (value instanceof KodeObject) {
            return (KodeObject) value;
        } else {
            throw new RuntimeError("Unsupported Data-Type.");
        }
    }

    /**
     * Converts a Java Array data-type to List data-type when pass as a single
     * object.
     */
    static private List<Object> ArrayObject2List(Object array) {
        Class<?> ofArray = array.getClass().getComponentType();
        if (ofArray.isPrimitive()) {
            List<Object> ar = new ArrayList<>();
            int length = Array.getLength(array);
            for (int i = 0; i < length; i++) {
                ar.add(Array.get(array, i));
            }
            return ar;
        } else {
            return Arrays.asList((Object[]) array);
        }
    }

    /**
     * Converts an KODE object to suitable Java object. If it fails to do its
     * task, then it returns the object without converting it.
     */
    static Object toJava(KodeObject value) {
        if (value instanceof KodeInstance) {
            if (ValueNone.isNone((KodeInstance) value)) {
                return null;
            }
            if (ValueNumber.isNumber((KodeInstance) value)) {
                return ValueNumber.toNumber(value);
            }
            if (ValueString.isString((KodeInstance) value)) {
                return ValueString.toStr(value);
            }
            if (ValueBool.isBool((KodeInstance) value)) {
                return ValueBool.toBoolean(value);
            }
            if (ValueList.isList((KodeInstance) value)) {
                return ValueList.toList(value).stream().map(Interpreter::toJava).collect(Collectors.toList());
            }
        }
        return value;
    }

}
